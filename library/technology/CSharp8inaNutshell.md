# C# 8.0 in a Nutshell
__By: Joseph Albahari__
## Lessons Learned: 
- The C# compiler compiles source code into an assembly. An assembly is the unit of packaging and deployment in .NET. An assembly can be either an application or a library. A normal concise or windows application has a Main method, whereas a library does not
- Data members and function members that don’t operate on the he instance of the type but rather on the type itself must be marked as static. For example, you never actually create instances of a Console for Console.WriteLine, one console is shared across
- All C# types fall into the categories value types (comprise most built in types), reference types (comprise all class, array, delegate, and interface types), generic type parameters, and pointer types.
- Ternary operator has the form `q ? a : b`. Thus, if condition q is true, a is evaluated, else b is evaluated.
- You can’t explicitly delete objects in c#, as you can in c++. An unreferenced object is eventually collected by the garbage collector
- namespaces are independent of assemblies, which are units of deployment such as an .exe or .dll
- Making fields or properties read-only is good practice when there is no valid reason for them to change throughout the life of the object
- A property is declared like a field but with a get and set block added. Get and set denote property accessors.
- Polymorphism works in the basis that subclasses have all the features of their base class
- A delegate is an object that knows how to call a method. A delegate is an object which refers to a method or you can say it is a reference type variable that can hold a reference to the methods. It provides a way which tells which method is to be called when an event is triggered.  For example, if you click on a Button on a form (Windows Form application), the program would call a specific method. In simple words, it is a type that represents references to methods with a particular parameter list and return type and then calls the method in a program for execution when it is needed. Delegates are immutable
- Covariance applies to generic parameters type used as method return type. The type parameter T of the `IEnumerable<out T>` is covariant because it is declared with an out keyword. This means that an IEnumerable<Derived> reference can be assigned to an IEnumerable<Base> reference. Assuming A is convertible to B, X has a covariant type parameter if X<A> is convertible to X<B>. Contravariance is enforced in relation to a particular generic type using in the generic modifier. Contravariance applies to generic parameters type used as method parameter. A good example from the Base Class Library (the BCL) is IComparer<in T>. Contravariance is when you can convert in the reverse direction to covariance from X<B>  to X<A>. This is supported if the type parameter appears only in input positions and is designated with the in modifier. Covariance and contravarience (or simply "variance") are advanced concepts, in particular, thos defined in .NET core such as IEnumerable<T>.
- An enum is a special value type that lets you specify a group of named numeric constants. For example, public enum BorderSide { Left, Right, Top, Bottom}. Then you can call BorderSide.Top
- Serialization - the process of converting arbitrary objects to and from a particular format for storage or transmission.
- Anonymous types are simple classes created by the compiler on the fly to store a set of values. To create an anonymous type, use the new keyword followed by an object initializer, specifying the properties and values the type with contain. For example: `var dud = new { name = “bob”,  age = 23 }`
- A lambda expression is an unnamed method written in place of a delegate instance. It is written as `(parameters) => expression-or-statement-block`. An example would be `x => x*x`;
- When using delegates, two emergent roles commonly appear: broadcaster and subscriber. The broadcaster is a type that contains a delegate field. The broadcaster decides when to broadcast, by invoking the delegate. The subscribers are the method target recipients. A subscriber decides when to start and stop listening by calling += and -= on the broadcaster's delegate. A subscriber does not know about, or interfere with, other subscribers. Events are a language feature that formalizes this pattern. An event is a construct that exposes just the subset of delegate features required for the broadcaster/subscriber model. The main purpose of events is to prevent subscribers from interfering with one another.
- A generic type declares type parameters-placeholder types to be filled in by the consumer of the generic type, which supplies the type argument. Here is a generic type Stack<T>, designed to stack instances of type T. By convention, generic types and methods with a single parameter typically name their parameter T, as long as the intent of the parameter is clear. When using multiple type parameters, each parameter is prefixed with T, but has a more descriptive name, like Tinteger or Tstring
- Boxing is the act of converting a value type instance, like an int, to a reference type instance, like an object.
- An interface is similar to a class, but only specifies behavior and does not hold data. An interface can define only functions and not fields. Interface members are implicitly abstract. A class can implement multiple interfaces
- Use classes and subclasses for types that naturally share implementations. Use interfaces for types that have independent implementations.
- An interface is like a class that cannot hold data. This means that it can define only behavior, which allows for multiple inheritance as well as a separation between specification and implementation.
- C# depends on a common language runtime (CLR), which provides essential runtime services such as automatic memory management and exception handling
- C# is called a manager language because it complies source code into managed code, which is represented in intermediate language.