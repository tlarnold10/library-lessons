# Angular Development with Typescript
__By: Yakov Fain__
## Lessons Learned:
- Imagine a component with a link that only logged-in users can navigate to. To guard this route, you need to create a new class (for example, `LoginGuard`) that implements the `CanActivate` interface, which declares one method, `canActivate()`. In this method, you implement the validating logic that will return either `true` or `false`. If `canActivate()` of the guard returns true, the user can navigate to the route. You need to assign this guard to the property `canActivate`, as in the following listing.
- If you want to make sure that by the time the user navigates to a route some data structures are populated, create a `Resolve` guard that allows getting the data before the route is activated. A resolver is a class that implements the `Resolve` interface. The code in its `resolve()` method loads the required data, and only after the data arrives does the router navigate to the route.
- In Angular, you can use the `@ViewChild()` decorator to get a reference to an element from a component template. To uniquely identify the template elements, you’ll use local template variables that start with the hash symbol. The following code snippet uses the local template variable `#stockSymbol` as an ID of the `<input>` element: `<input type="text" #stockSymbol placeholder="Enter stock">` . If you need to get a reference to the preceding element inside the TypeScript class, you can use the `@ViewChild('stockSymbol')` decorator, and the application in the following listing illustrates how to do that. Note that you import only those RxJS members that you actually use.
- The `FormControl` class, one of the fundamental blocks of forms processing, represents a form control. By default, whenever the value of the form control changes, the underlying `FormControl` object emits an event through its `valueChanges` property of type `Observable`, and you can subscribe to it.
- . Angular offers an `AsyncPipe` that can take a component property of type `Observable`, autosubscribe to it, and render the result in the template.
- The router is responsible for managing client-side navigation, and later in this chapter we provide a high-level overview of the router. In the non-SPA world, site navigation is implemented by a series of requests to a server, which refreshes the entire page by sending the appropriate HTML documents to the browser. With SPAs, the code for rendering components is already on the client (except for the lazy-loading scenarios) and you need to replace one view with another.
- In SPAs, you need the ability to modify the URL without forcing the browser to make a server-side request so the application can locate the proper view on the client. Angular offers two location strategies for implementing client-side navigation:
	- `HashLocationStrategy` — A hash sign (#) is added to the URL, and the URL segment after the hash uniquely identifies the view to be used as a web page fragment. This strategy works with all browsers, including the old ones.
	- `PathLocationStrategy` — This `History` API–based strategy works only in browsers that support HTML5. This is the default location strategy in Angular.